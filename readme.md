# 游戏程序员之路

大部分人并没有Milo的经历，精力和能力有限，因此裁剪一下自己的游戏程序员之路。

展示我已经阅读过的书，以及将要阅读的书。

## 相关连接

[游戏程序员的学习之路](http://wiki.cgt3d.cn/mediawiki/index.php/%E6%B8%B8%E6%88%8F%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF)

## 构建

编辑dot文件，Linux上构建，然后把图片文件下载回来提交

安装：graphviz

构建：`make`

## 开发指南

工具：Pycharm Remote Deployment

* Pycharm将本地代码上传到Linux服务器
* 编辑dot文件，自动上传
* 远程make
* Pycharm的Remote Host窗口直接查看png文件，可以与原版图片对比

## 我的游戏程序员之路

默认是我看过的书，自认为已经掌握核心概念，但是也不敢说100%细节都知道，大部分有待实践。

对于CSAPP这种大部书，只能说常读常新，也不要求完全掌握，因为不是所有的章节游戏开发都需要熟悉。

蓝色框的是我将要看的书。

## 计算机科学

![](1_cs.png)

* CSAPP，计算机体系结构，CPU架构和缓存优化
  * 先从代码层面优化入手，之后深入硬件
* CAAQA，并行计算架构，服务端和GPU都有用
* 操作系统
  * 多线程编程需要
  * 熟悉Linux日常开发概念
* 算法
  * 不专精纯算法，高级数据结构
  * 基本内容要了解，满足日常开发
  * 熟悉某一种STL实现，folly，Lua的字符串和表实现
  * 熟悉各种游戏相关算法，在后面具体讨论
* 数学，游戏有专门的数学，后面讨论，而这里的离散数学和计算数学离实际应用太远了

## 程序语言

![](2_proglang.png)

程序语言是程序员第一级别的工具，也是trust base

相比于程序语言，游戏功能，界面，编辑器都是建立在程序基础之上的，功能和需求变化大，而且会有BUG

游戏开发中，程序语言分为两种，脚本语言和引擎语言C++

脚本语言随引擎和项目学习使用即可，C++则是重点，和需要长期学习的

程序语言的应用分两个层面，一是使用，二是编译器/解释器开发

以C#为例，《深入理解C#》就是使用层面，用C#来开发程序；《CLR via C#》就是编译器层面，去了解C#的运行时实现细节

脚本语言接入引擎需要编译器开发技能，这也是一块大工程，需要持续跟进优化。

C++的坑很深，不打算深入了解编译器和模板黑魔法，以日常开发为目标学习，能维持ZeloEngine开发即可

## 软件工程

软件工程是很重要的，主要是解决如何维护长达2~3年以上生命周期的代码库

好的软件架构，能够维持很长的生命周期，易于扩展功能；再不济就是需要重构，再不行已经崩了就只能重写了

对于单个程序员，软件工程有一个问题，就是太虚了，无法量化，快速实践和反馈

相关书籍都很有名，《人月神话》，《重构》

看是要看的，但是无法直接对应输出，在此不列书单

倾向于以实践为主，也就是自己去写足够大的程序，比如把项目代码维护好，比如写ZeloEngine

有几个点：
* 设计模式
  * 我的理解，语言是最高级的设计模式，语言本身的设计对传统意义的“设计模式”影响非常大，Peter Norvig有一篇文章可以看下
  * 然后是框架是第二层设计模式，在这一层，事件系统（观察者模式）等都已被封装
  * 然后才是传统的设计模式，也就是日常开发中会用到的惯用写法
* UML
  * 严格的UML那一套效率很低，规则很繁琐
  * 但是UML是一种程序设计工具，在需求和实现分析阶段非常重要，流程图，时序图，状态图是常用的
  * 实际日常开发中，会因为需求变化太快，需求质量低而不值得做UML，但是这个技能是需要掌握的
* 重构
  * 非常吃实践，基本做法是划定一个足够小的范围，然后重构以达到代码质量提升的目标
* 代码规范
  * 保持统一
* 最佳实践
  * 平时积累

## 游戏逻辑

没有固定路线，以做游戏为主

下面这两部书作为补充，时间长了，基本所有内容都会覆盖到，不必一开始捧着书读完再去写代码
* 游戏编程算法技巧
* 游戏编程模式

## 游戏引擎

游戏引擎架构

## 渲染

理论基础
* 虎书
* PBRT

## 物理

* 实时碰撞检测算法

## 动画

pass

## AI

pass

## 网络编程

pass

